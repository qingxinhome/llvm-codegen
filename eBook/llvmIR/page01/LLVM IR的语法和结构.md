LLVM IR 

#### 1. 学习内容概述

内容分为四个模块，逐步构建知识体系。每个模块包括关键概念、API 和实践目标。

- **模块 1: LLVM IR 基础与环境搭建**
  - 关键概念：理解 LLVM IR 的结构（模块、函数、基本块、指令、值和类型）。IR 是 LLVM 的中间表示，用于优化和代码生成。
  - 核心 API：LLVMContext（上下文管理）、Module（模块容器）、Type（类型系统，如 IntegerType、FunctionType）。
  - 实践目标：安装 LLVM，编写简单程序创建空模块并输出 IR。
- **模块 2: 生成函数和基本块**
  - 关键概念：函数定义、参数处理、基本块（BasicBlock）作为代码段。
  - 核心 API：Function（函数类，构造函数如 Function(const FunctionType *Ty, LinkageTypes Linkage, const std::string &N = "", Module* Parent = 0)）、BasicBlock（构造函数如 BasicBlock(const std::string &Name = "", Function *Parent = 0)）、getEntryBlock()、insert() 等。
  - 实践目标：生成一个简单函数（如加法函数），添加基本块，并使用 IRBuilder 插入指令。
- **模块 3: 生成指令和控制流**
  - 关键概念：指令类型（二元操作、分支、返回等）、值（Value）和用户（User）。
  - 核心 API：Instruction（指令基类，如 getParent()）、IRBuilder（简化指令生成，如 CreateAdd、CreateRet）、isa<>、cast<>（类型检查和转换）。
  - 实践目标：实现条件分支、循环和数学运算的 IR 生成，并验证输出。
- **模块 4: 高级主题与数据库应用**
  - 关键概念：优化传递（Pass）、JIT 编译、向量化。
  - 核心 API：PassManager、ExecutionEngine（用于 JIT）、getOrInsertFunction()（插入外部函数）。
  - 实践目标：集成到简单查询引擎原型中，生成数据库运算（如聚合）的 IR，并测量性能。





### LLVM IR 的语法结构（Syntax）

## 语法

### 一、标识符

LLVM标识符有两种基本类型：全局标识符和局部标识符。全局标识符包括函数和全局变量，以'@'字符开头；局部标识符包括局部变量和type类型，以'%'字符开头。此外，标识符还有三种不同的格式，用于不同的目的：

1) 命名的值：由前缀（@或者%）加字符串表示，比如%foo等。识别变量的正则表达式为‘`[%@][-a-zA-Z$._][-a-zA-Z$._0-9]*`’.如果名称中需要包含其他字符，可以用引号包围。特殊字符可以使用 "\xx" 转义，其中 xx 是字符的十六进制 ASCII 码。这种全局变量和局部变量，就相当于C中的指针变量，如果是函数就是函数指针。 

2. 未命名的值:  由无符号数字加上前缀表示，例如，%12、@2、%44.

3. 常量，在下面的 Constants 部分中描述。



LLVM 要求标识符以一个前缀开头有两个方面的原因：一是编译器不需要担心与保留字的名称冲突，并且将来可以无代价地扩展保留字集合。此外，未命名的标识符允许编译器快速生成临时变量，而无需避免符号表冲突。所谓临时变量，就是当计算结果没有分配给指定变量时，就会创建未命名的临时变量，未命名的临时变量的数字是按顺序编号的，从0开始，比如%0、%1，%2。

LLVM 中的保留字与其他语言中的保留字非常相似。有用于不同操作符的关键字（如 '`add`'、'`bitcast`'、'`ret`' 等）、基本类型名称（如 '`void`'、'`i32`' 等）以及其他。这些保留字不会与变量名称冲突，因为它们都不以前缀字符（'%' 或 '@'）开头。



以下是 LLVM 代码示例，用于将整数变量 `%X` 乘以 8：

简单方式：

```
%result = mul i32 %X, 8
```

左移优化方式：

```
%result = shl i32 %X, 3
```

多次加法的复杂方式：

```
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           /* yields i32:%1 */
%result = add i32 %1, %1
```

这个最后一种将 `%X` 乘以 8 的方式展示了 LLVM 的几个重要词法特征：

1. 注释以 '`;`' 分隔，并持续到行尾。或者，注释可以以 `/*` 开始，以 `*/` 结束。
2. 当计算结果未分配给命名值时，会创建无名临时变量， 如%0， %1就是临时变量。
3. 默认情况下，没有命名的临时变量会按顺序编号（使用每个函数的递增计数器，从 0 开始）。但是，在显式指定临时编号时，允许跳过编号。

  注意: 基本块和没有命名的函数参数也包含在此编号中。例如，如果入口基本块未给出标签名称，并且所有函数参数均已命名，则它将获得编号 0。

它还显示了我们在本文档中遵循的IR编码惯例。在演示指令时，我们将在指令后面加上注释，定义所生成值的类型和名称。

**解释：**

- **标识符的分类与规则**：LLVM IR 强调强类型和唯一性，全局标识符（如函数）用 `@` 前缀，局部（如寄存器）用 `%`。这避免了与保留字冲突，并允许编译器自由扩展语言。命名值支持灵活字符（通过转义），这在处理复杂名称时有用，例如从高级语言生成的IR。无名值（如 `%12`）用于临时结果，简化优化过程。
- **示例分析**：示例展示了如何用不同指令实现乘法（mul、shl、add），突出 SSA（Static Single Assignment）形式：每个变量只赋值一次。注释语法类似于 C，但 LLVM 的注释在行尾以 ';' 开头。无名临时变量的编号是函数级的，从 0 开始，包括基本块和参数，这确保了IR的唯一性和可追踪性。
- **实际应用**：在编写或生成 IR 时，确保标识符唯一以避免冲突。转义机制允许包含特殊字符，如在调试信息中嵌入源代码文件名。
- **注意事项**：保留字不能用于变量名，但可以扩展而不破坏现有代码。这体现了 LLVM 的设计哲学：低级但灵活。

#### 

### 二、字符串常量

LLVM 程序中的字符串以 `"` 字符分隔。在一个字符串中，所有字节都按字面意思处理，除了 `\` 字符（它启动转义）和第一个 `"` 字符（它结束字符串）。

**有两种转义：**

* `\\` 表示单个 `\` 字符。
* `\` 后跟两个十六进制字符（0-9、a-f 或 A-F）表示具有给定值的字节（例如，`\00` 表示空字节）。

要表示 `"` 字符，请使用 `\22`。（`\"` 将以尾随 `\` 结束字符串）

换行符不会终止字符串常量，字符串可以跨越多行。

字符串常量的解释（例如，其字符编码）取决于上下文。

示例：

```c
@str = constant [6 x i8] c"hello\00"  ; C 风格字符串
```

**解释：**

- **字符串的表示与转义**：LLVM 的字符串类似于 C 风格，但更严格：所有字节字面处理，转义仅用于特殊字符（如 `\xx`）。这确保了精确的字节级控制，适合嵌入二进制数据（如常量数组）。多行字符串通过 `\` 续行，但需注意续行后的空格会被保留（原文中提到“whitespace is discarded”，但实际在 LLVM 中，多行字符串的续行会忽略续行符后的空格，除非是字符串的一部分）。
- **上下文依赖**：字符串的编码取决于使用场景，例如在全局变量中可能作为字节数组（如 `c"hello\00"` 用于 C 风格字符串），或在元数据中作为文本。`\22` 用于嵌入引号，避免解析错误。
- **实际应用**：常用于常量初始化，如全局字符串 `@str = constant [6 x i8] c"hello\00"`。这在生成机器码时确保精确的内存布局。
- **注意事项**：字符串不自动添加 null 终止符，除非显式添加 `\00`。跨越多行时，确保格式正确，以避免解析错误。在 LLVM IR 中，字符串常量常用于调试信息或嵌入数据。



#### 示例 1：命名值和无名值的结合

这个示例定义一个全局变量、一个函数，并在一个函数中使用命名和无名局部变量。

identifier_example.ll

```
; 全局变量（命名全局标识符）
@my_global = global i32 42

; 函数声明（命名全局标识符）
declare i32 @puts(ptr)

; 函数定义（命名全局标识符）
define i32 @main() {
entry:
  ; 命名局部变量
  %my_var = alloca i32
  store i32 10, ptr %my_var

  ; 无名局部变量（自动编号为 %0）
  %0 = load i32, ptr %my_var
  ; 无名局部变量（编号为 %1）
  %1 = add i32 %0, 8

  ; 命名局部变量（显式命名）
  %result = shl i32 %1, 3  ; 左移，等价于 *8

  ; 调用 puts，传递全局字符串
  call i32 @puts(ptr @.str)
  ret i32 %result
}

; 全局字符串常量（命名全局标识符）
@.str = private unnamed_addr constant [12 x i8] c"Hello World\00"
```

**解释**：

- **全局标识符**：
  - @my_global：全局变量，存储整数 42。
  - @main：函数名，定义程序入口。
  - @.str：全局字符串常量，命名以点开头（常见约定）。
  - @puts：外部函数声明。
- **局部标识符**：
  - %my_var：命名局部变量，分配在栈上。
  - %0、 %1：无名局部变量，自动编号，从 0 开始。
  - %result：命名局部变量，存储计算结果。

### 

#### 示例 2：使用转义字符的命名标识符

展示如何在标识符中使用特殊字符（如引号或非 ASCII 字符）。

escaped_identifier.ll

```
; 全局变量，名称包含特殊字符
@"my\22special\22var" = global i32 100

; 函数，使用转义名称的全局变量
define i32 @test_special() {
    ; 访问带转义字符的全局变量
    %1 = load i32, ptr @"my\22special\22var"
    %result =  add i32 %1, 50
    ret i32 %result
}
```



**解释**：

**转义标识符**：@"my\22special\22var" 使用 \22 表示引号（"），生成名称 my"special"var。这在需要嵌入特殊字符（如源代码中的符号）时有用。

**用途**：常用于从高级语言（如 C++）生成 IR 时，保留复杂符号名。\01 前缀（未在此例中使用）可用于全局变量以避免名称重整（mangling）。

**注意**：转义字符需符合正则表达式 [%@][-a-zA-Z$._][-a-zA-Z$._0-9]*，否则需用引号包裹。



#### 示例 3：字符串常量作为全局变量

字符串常量以 " 分隔，支持 \xx 转义字节，跨行定义，且编码依上下文而定。以下示例。展示如何定义 C 风格字符串（以 null 结尾）并在函数中使用。

string_constant.ll

```
; 定义全局字符串常量
@msg = private unnamed_addr constant [14 x i8] c"Hello, LLVM!\0A\00"

; 声明 puts 函数
declare i32 @puts(ptr)

; 定义 main 函数
define i32 @main() {
entry:
  ; 调用 puts 打印字符串
  call i32 @puts(ptr @msg)
  ret i32 0
}
```



**解释**：

- **字符串常量**：c"Hello, LLVM!\0A\00" 定义一个 14 字节数组，包含 ASCII 字符串 "Hello, LLVM!"，加上换行符 \0A（ASCII 10）和 null 终止符 \00（ASCII 0）。
- **上下文**：字符串存储为 [14 x i8] 类型的全局常量，c 前缀表示字符数组。@msg 是全局标识符，private 和 unnamed_addr 表示私有且地址无关。
- **用途**：**常用于嵌入 C 风格字符串，供 puts 或其他函数使用**。puts 期望以 null 结尾的字符串，因此 \00 不可省略。
- **验证**：运行此 IR（用 llvm-as 和 llc 编译后链接）会打印 "Hello, LLVM!" 并换行。



#### 示例 4：跨行字符串与转义字符

展示字符串常量跨行定义和嵌入特殊字符。

multiline_string.ll

```
; 定义跨行字符串常量
@long_str = private unnamed_addr constant [48 x i8] c"This is a long\0A
string spanning\0A
multiple lines\00"

; 声明 puts 函数
declare i32 @puts(ptr)

; 定义 main 函数
define i32 @main() {
entry:
  call i32 @puts(ptr @long_str)
  ret i32 0
}
```

**解释**：

- **跨行字符串**：字符串 "This is a long\nstring spanning\nmultiple lines\00" 使用 \ 续行，分三行定义。**\0A 表示换行**，**\00 终止字符串**。
- **字节级控制**：字符串常量按字节存储，[48 x i8] 表示 48 个 8 位字节，精确匹配字符串内容（包括换行和 null）。



#### 示例5： 结合标识符和字符串常量的综合示例

这个示例展示如何在函数中结合命名/无名标识符和字符串常量，模拟一个简单程序。

combined_example.ll

```
; 全局字符串常量
@greeting = private unnamed_addr constant [16 x i8] c"Welcome to LLVM\00"

; 全局变量
@counter = global i32 0

; 声明 puts 函数
declare i32 @puts(ptr)

; 定义 main 函数
define i32 @main() {
entry:
    ; 命名局部变量，分配栈空间
    %temp = alloca i32
    ; 存储局部变量 temp 值
    store i32 5, ptr %temp

    ; 无名局部变量，加载 temp
    %0 = load i32, ptr %temp
    ; 无名局部变量，计算 temp * 8
    %1 = shl i32 %0, 3

    ; 命名局部变量，存储结果
    %final_result = add i32 %1, 2

    ; 更新全局 counter
    store i32 %final_result, ptr @counter

    ; 打印greeting
    call i32 @puts(ptr @greeting)
    ret i32 %final_result
}

```

**解释**：

- **标识符**：
  - 全局：@greeting（字符串常量）、@counter（全局变量）、@puts（函数）、@main（函数）。
  - 局部：%temp（命名，栈变量）、%0、 %1（无名，临时变量）、%final_result（命名，结果）。
- **字符串常量**：c"Welcome to LLVM\00" 是一个 15 字节的 C 风格字符串，用于 puts 输出。
- **逻辑**：程序分配栈变量 %temp，存储 5，左移 3 位（*8 得 40），加 2（得 42），存入 @counter，打印 "Welcome to LLVM"，返回 42。
- **用途**：展示如何在函数中混合使用标识符和字符串常量，适用于生成简单的命令行程序。